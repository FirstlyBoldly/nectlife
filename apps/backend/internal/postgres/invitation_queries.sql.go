// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitation_queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptInvitationByToken = `-- name: AcceptInvitationByToken :exec
UPDATE "invitation"
SET "status" = 'accepted'
WHERE "token" = $1
`

func (q *Queries) AcceptInvitationByToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, acceptInvitationByToken, token)
	return err
}

const checkForExpiredInvitations = `-- name: CheckForExpiredInvitations :exec
UPDATE "invitation"
SET "status" = 'expired'
WHERE NOW() >= "expires_at"
AND "status" = 'pending'
`

func (q *Queries) CheckForExpiredInvitations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, checkForExpiredInvitations)
	return err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO "invitation" (
  "invited_by_user_id",
  "student_id",
  "email",
  "token",
  "role_id",
  "expires_at"
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, invited_by_user_id, student_id, email, token, role_id, expires_at, status, created_at
`

type CreateInvitationParams struct {
	InvitedByUserID pgtype.Int4
	StudentID       string
	Email           string
	Token           string
	RoleID          int32
	ExpiresAt       pgtype.Timestamptz
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.InvitedByUserID,
		arg.StudentID,
		arg.Email,
		arg.Token,
		arg.RoleID,
		arg.ExpiresAt,
	)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.InvitedByUserID,
		&i.StudentID,
		&i.Email,
		&i.Token,
		&i.RoleID,
		&i.ExpiresAt,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}
